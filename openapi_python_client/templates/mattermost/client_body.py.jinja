{% set keyword_type_async = 'Async' if async_class == True else '' %}
{% set keyword_async = 'async ' if async_class == True else '' %}
{% set keyword_await = 'await ' if async_class == True else '' %}
{% set client_type = 'Async' if async_class == True else 'Sync' %}
from contextlib import {{keyword_type_async | lower}}contextmanager
from typing import Optional

import httpx
from pydantic import PrivateAttr

from .base import AuthLogin, AuthToken, BaseClient, HttpxClientOptions
from .exceptions import (
    ContentTooLarge,
    FeatureDisabled,
    InternalServerError,
    InvalidOrMissingParameters,
    MethodNotAllowed,
    NoAccessTokenProvided,
    NotEnoughPermissions,
    ResourceNotFound,
    TooManyRequests,
)


{% for tag in tags: %}
from ..endpoints.{{client_type | lower}}_api.{{tag | snakecase}} import {{tag | pascalcase}}Api
{% endfor %}


class {{ client_type }}Client(BaseClient):
    """Synchronous mattermost api client implementation"""

    _httpx_client: Optional[httpx.{{ keyword_type_async }}Client] = PrivateAttr(None)
    """ The underlying httpx client which handles requests to the api in case we are inside a session """

    {{keyword_async}}def _create_httpx_client(self):
        """Create a httpx.{{ keyword_type_async }}Client instance to be used for requests and perform authentication if needed"""
        client_options = (
            self.options.client_options
            if self.options.client_options
            else HttpxClientOptions()
        )
        base_url = str(httpx.URL(self.options.url).join(self.options.basepath))
        client = httpx.{{  keyword_type_async }}Client(base_url=base_url, **dict(client_options))
        client.event_hooks["response"] = [self.raise_on_4xx_5xx] + client.event_hooks[
            "response"
        ]
        if isinstance(self.options.auth, AuthToken):
            client.auth = self.options.auth
            self.active_token = self.options.auth.token
        if isinstance(self.options.auth, AuthLogin):
            """Login with username and password and get a session_token"""
            response = {{keyword_await}}client.post(
                url="/users/login", json=self.options.auth.dict(exclude_unset=True)
            )
            session_token = response.headers.get("token", None)
            client.auth = AuthToken(token=session_token)
            self.active_token = session_token
        return client

    {{keyword_async }}def raise_on_4xx_5xx(self, response):
        try:
            response.raise_for_status()
        except httpx.HTTPStatusError as e:
            try:
                {% if async_class %}
                await e.response.aread()
                {% else %}
                e.response.read()
                {% endif %}
                data = e.response.json()
                message = data.get("message", data)
            except ValueError:
                message = response.text
            if e.response.status_code == 400:
                raise InvalidOrMissingParameters(message) from e
            if e.response.status_code == 401:
                raise NoAccessTokenProvided(message) from e
            if e.response.status_code == 403:
                raise NotEnoughPermissions(message) from e
            if e.response.status_code == 404:
                raise ResourceNotFound(message) from e
            if e.response.status_code == 405:
                raise MethodNotAllowed(message) from e
            if e.response.status_code == 413:
                raise ContentTooLarge(message) from e
            if e.response.status_code == 429:
                raise TooManyRequests(message) from e
            if e.response.status_code == 500:
                raise InternalServerError(message) from e
            if e.response.status_code == 501:
                raise FeatureDisabled(message) from e
            raise

    {{keyword_async }}def _login(self):
        """Calling this creates a client and sets .active_token, needed for websockets"""
        {{keyword_await }}self._create_httpx_client()

    @{{keyword_type_async | lower}}contextmanager
    {{ keyword_async }}def _get_httpx_client(self):
        """Get the currently set httpx.Client instance or create a new one"""
        if not self._httpx_client or self._httpx_client.is_closed:
            httpx_client = {{keyword_await}}self._create_httpx_client()
            try:
                yield httpx_client
            finally:
                {% if async_class %}
                await httpx_client.aclose()
                {% else %}
                httpx_client.close()
                {% endif %}
        else:
            yield self._httpx_client

    @{{keyword_type_async | lower}}contextmanager
    {{ keyword_async }}def session(self):
        """Open a Session which re-uses the underlying httpx client and it's connections"""
        api_client = self.copy()
        api_client._httpx_client = {{ keyword_await }}api_client._create_httpx_client()
        try:
            yield api_client
        finally:
            {% if async_class %}
            await api_client._httpx_client.aclose()
            {% else %}
            api_client._httpx_client.close()
            {% endif %}

    {% for tag in tags: %}
    @property
    def {{tag | snakecase}}(self) -> {{tag | pascalcase}}Api:
        """Api endpoint for {{tag | pascalcase}}

        :type: :class:`~matterapi.endpoints.{{client_type | lower}}_api.{{tag | pascalcase}}Api`
        """
        return {{tag | pascalcase}}Api(client=self, skip_response_parsing=self.options.skip_response_parsing)
    {% endfor %}

