from typing import Dict, Optional, Any, Union
from pydantic import BaseModel, AnyHttpUrl, validator, PrivateAttr
import httpcore
import httpx
import logging

from .exceptions import (
        InvalidOrMissingParameters,
        NoAccessTokenProvided,
        NotEnoughPermissions,
        ResourceNotFound,
        MethodNotAllowed,
        ContentTooLarge,
        FeatureDisabled,
        TooManyRequests,
        InternalServerError)


log = logging.getLogger('mattermost_api.client')
log.setLevel(logging.INFO)


class ClientOptions(BaseModel):
    """ Options for the http client """
    timeout: Optional[float] = 10.0
    """ Timeout for operations """
    verify: Union[bool, Any] = True
    """ If and how TLS should be verified. """
    cert: Optional[Any]
    proxies: Optional[Dict]
    auth: Optional[Any]

class BaseClient(BaseModel):
    """ A class for keeping track of data related to the API """

    base_url: AnyHttpUrl
    cookies: Optional[Dict[str, str]]
    headers: Optional[Dict[str, str]]
    client_options: Optional[ClientOptions]

    def get_headers(self) -> Dict[str, str]:
        """ Get headers to be used in all endpoints """
        return self.headers or {}

    def get_cookies(self) -> Dict[str, str]:
        return self.cookies or {}

    def get_timeout(self) -> float:
        return self.client_options.timeout

    def _check_response(self, response):
        try:
            response.raise_for_status()
        except httpx.HTTPStatusError as e:
            try:
                data = e.response.json()
                message = data.get('message', data)
            except ValueError:
                log.debug('Could not convert response to json')
                message = response.text
            log.error(message)
            if e.response.status_code == 400:
                raise InvalidOrMissingParameters(message) from e
            if e.response.status_code == 401:
              raise NoAccessTokenProvided(message) from e
            if e.response.status_code == 403:
              raise NotEnoughPermissions(message) from e
            if e.response.status_code == 404:
              raise ResourceNotFound(message) from e
            if e.response.status_code == 405:
              raise MethodNotAllowed(message) from e
            if e.response.status_code == 413:
              raise ContentTooLarge(message) from e
            if e.response.status_code == 429:
              raise TooManyRequests(message) from e
            if e.response.status_code == 500:
              raise InternalServerError(message) from e
            if e.response.status_code == 501:
                raise FeatureDisabled(message) from e
                
            raise


class SyncClient(BaseClient):

    {#

    _client : Any = PrivateAttr()
    @property
    def client(self):
        if not getattr(self, '_client', None):
            options = self.client_options.dict() if self.client_options else {}
            self._client = httpx.Client(**options)
            return self._client
    #}

    {% for method in methods %}
    def {{method | lower}}(self, **kwargs):
        options = self.client_options.dict() if self.client_options else {}
        with httpx.Client(**options) as client:
            response = client.{{method | lower}}(**kwargs)
            self._check_response(response)
            return response
    {%endfor %}


class SyncAuthenticatedClient(SyncClient):
    """ A Client which has been authenticated for use on secured endpoints """
    auth_token: str

    def get_headers(self) -> Dict[str, str]:
        headers = self.headers or {}
        """ Get headers to be used in authenticated endpoints """
        return {"Authorization": f"Bearer {self.auth_token}", **headers}



class AsyncClient(BaseClient):
    {#
    _transport : Any = PrivateAttr()

    @property
    def transport(self):
        if not getattr(self, '_transport', None):
            self._transport = httpcore.AsyncConnectionPool()
        return self._transport
    #}

    {% for method in methods %}
    async def {{method | lower}}(self, **kwargs):
        options = self.client_options.dict() if self.client_options else {}
        async with httpx.AsyncClient(**options) as client:
            response = await client.{{method | lower}}(**kwargs)
            self._check_response(response)
            return response
    {%endfor %}

class AsyncAuthenticatedClient(AsyncClient):
    """ A Client which has been authenticated for use on secured endpoints """
    auth_token: str

    def get_headers(self) -> Dict[str, str]:
        headers = self.headers or {}
        """ Get headers to be used in authenticated endpoints """
        return {"Authorization": f"Bearer {self.auth_token}", **headers}

